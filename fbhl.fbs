
namespace fbhl;

enum EnumUnaryOp : byte {
  NONE = 0,
  NEG  = 1,
  NOT  = 2
}

union AST_OneOf {
  AST_Import, 
  AST_Module,
  AST_Interim,
  AST_UnaryOpExp,
  AST_BinaryOpExp,
  AST_Inc,
  AST_New,
  AST_FuncDecl,
  AST_ClassDecl,
  AST_EnumDecl,
  AST_TypeCast,
  AST_Call,
  AST_Return,
  AST_Break,
  AST_LiteralStr,
  AST_LiteralNum,
  AST_LiteralBool,
  AST_LiteralNil,
  AST_VarDecl,
  AST_Block,
  AST_JsonObj,
  AST_JsonArr,
  AST_JsonArrAddItem,
  AST_JsonPair,
  AST_PopValue,
}

table AST_Selector {
  v : AST_OneOf;
}

table AST_Import {
  modules : [uint32];
}

table AST_Interim {
  children : [AST_Selector];
}

table AST_Module {
  nname    : uint32;
  name     : string;//for debug
  children : [AST_Selector];
}

table AST_UnaryOpExp {
  type     : EnumUnaryOp;
  children : [AST_Selector];
}

enum EnumBinaryOp : byte {
  NONE    = 0,
  AND     = 1,
  OR      = 2,
  ADD     = 3,
  SUB     = 4,
  MUL     = 5,
  DIV     = 6,
  MOD     = 7,
  GT      = 8,
  LT      = 9,
  GTE     = 10,
  LTE     = 11,
  EQ      = 12,
  NQ      = 13,
  BIT_OR  = 14,
  BIT_AND = 15
}

table AST_BinaryOpExp {
  type     : EnumBinaryOp;
  children : [AST_Selector];
}

table AST_Inc {
  nname : uint32;
}

table AST_New {
  ntype    : uint32;
  type     : string;//for debug
  children : [AST_Selector];
}

table UseParam {
  nname     : uint32;
  name      : string; //for debug
}

table Lambda {
  useparams: [UseParam]; //lambda's use params
}

table AST_FuncDecl {
  ntype    : uint32;
  type     : string; //for debug
  nname1   : uint32;
  nname2   : uint32; //NOTE: due to msgpack 64 bit error on Windows we have to split nname
  name     : string; //for debug
  lambda   : Lambda;
  children : [AST_Selector];
}

table AST_ClassDecl {
  nname     : uint32;
  name      : string;//for debug
  nparent   : uint32;
  parent    : string;//for debug
  children  : [AST_Selector];
}

struct EnumItem {
  nname     : uint32;
  value     : int32;
}

table AST_EnumDecl {
  nname     : uint32;
  name      : string;//for debug
  items     : [EnumItem];
}

table AST_TypeCast {
  ntype     : uint32;
  type      : string; //for debug
  children  : [AST_Selector];
}

enum EnumCall : byte {
  NONE          = 0,
  VAR           = 1,
  VARW          = 2,
  MVAR          = 3,
  MVARW         = 4,
  MVARREF       = 5,
  FUNC          = 6,
  MFUNC         = 7,
  ARR_IDX       = 8,
  ARR_IDXW      = 9,
  FUNC2VAR      = 10,
  FUNC_PTR      = 11,
  FUNC_PTR_POP  = 12,
}

//TODO: make it rather a union of more fine grained calls
table AST_Call {
  type        : EnumCall;
  nname1      : uint32;
  nname2      : uint32;
  name        : string; //for debug
  cargs_bits  : uint32; //NOTE: bitmask of set/unset args, max 32 args supported for now
  scope_ntype : uint32;
  line_num    : uint32;
  children    : [AST_Selector];
}

table AST_Return {
  children   : [AST_Selector];
}

table AST_Break {
}

table AST_LiteralStr {
  sval    : string;
}

table AST_LiteralNum {
  nval    : double;
}

table AST_LiteralBool {
  bval    : bool;
}

table AST_LiteralNil {
}

table AST_VarDecl {
  nname     : uint32;
  name      : string; //for debug
  ntype     : uint32;
  children  : [AST_Selector];
}

enum EnumBlock : byte {
  NONE            = 0,
  SEQ             = 1, 
  DEFER           = 2, 
  PARAL           = 3, 
  PARAL_ALL       = 4, 
  PRIO            = 5, 
  FOREVER         = 6, 
  IF              = 7, 
  WHILE           = 8, 
  FUNC            = 9, 
  UNTIL_FAILURE   = 10,
  UNTIL_FAILURE_  = 11,
  UNTIL_SUCCESS   = 12,
  NOT             = 13,
  SEQ_            = 14,
  EVAL            = 15,
  GROUP           = 16, 
}

table AST_Block {
  type     : EnumBlock;
  children : [AST_Selector];
}

table AST_JsonObj {
  ntype    : uint32;
  children : [AST_Selector];
}

table AST_JsonArr {
  ntype    : uint32;
  children : [AST_Selector];
}

table AST_JsonArrAddItem {
}

table AST_JsonPair {
  nname       : uint32;
  name        : string; //for debug
  scope_ntype : uint32;
  children    : [AST_Selector];
}

table AST_PopValue {
}

root_type AST_Module;

///////////////////////////////////////////////////////

table Func2Assets {
  func1  : uint32; //splitted uint64 
  func2  : uint32;
  assets : [string]; 
}

table Func2Crefs {
  func1  : uint32; //splitted uint64
  func2  : uint32;
  crefs  : [string]; 
}

table PostProcResult {
  func2assets : [Func2Assets];
  func2crefs  : [Func2Crefs];
}

///////////////////////////////////////////////////////

table ExportItem {
 format    : byte;  //0 - binary, 1 - lz4
 module_id : uint32; 
 blob      : [byte];
}

table ExportResult {
  items : [ExportItem];
}
